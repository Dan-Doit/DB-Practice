/*
DataBase Term
 - Relation = Table
 - Attribute = Field = Column = 속성 --> 일관된 데이터타입만 저장 가능
 - Tuple = Record = Row = 속성들의 집합
 - Domain : 속성이 취할 수 있는 값의 범위
 - Cardinality : Tuple의 수
 - Degree : Attribute의 수
 - Relation Schema : 속성의 이름
 - Relation Instance : Tuple의 집합

 - Key : Row를 구분하기 위한 하나 이상의 Column
   -- Primary Key : 수 많은 Record사이에서 현재 레코드의
                    유일한 특성을 갖게 하는 하나 이상의 속성
                  : 1개의 테이블에 1개의 PK만 존재
   -- Foreign Key : 1:N관계를 갖는 두 개의 테이블에서 N의 속성을 갖고 있는 테이블의 
                    Column Data는 반드시 1의 속성을 갖는 테이블의 Column Data와
                    일치시킴으로써 두 개의 테이블의 관계에서 Object Integrity와 
                    Reference Integrity을 유지하도록 한다.
                
                    
DataBase Normalization
   : 데이터의 중복으로 인한 이상(Anomaly) 현상 제거
   1. Insert Anomaly
      : 새로운 데이터를 삽입하기 위해 불필요한 데이터도 함께 삽입해야 하는 문제
   2. Update Anomaly
      : 중복 튜플 중 일부만 변경하여 데이터가 불일치하게 되는 문제 
   3. Deletion Anomaly
      : 데이터를 삭제할 경우 데이터가 포함된 레코드가 삭제되므로 삭제하지 말아야 할
        데이터도 함께 삭제되는 문제
*/
SELECT * FROM DBA_USERS;

/* 2020-10-19 User Creation 
    Syntax____
    CREATE USER [USER_NAME]
    IDENTIFIED BY "[PASSWORD]";
    
    PROCESS
     - USER CREATION
     - GRANT PRIVILEAGE
    EXEC
     1. LOCAL WORK
     2. LOCAL SHUTDOWN --> SERVER WORK
*/
CREATE USER HOONZZANG
IDENTIFIED BY "7777"; --> LACKS CREATE SESSION PRIVILEAGE 
-- DCL : GRANT[REVOKE] [PRIV_NAME | ROLE: 권한의 집합]
GRANT CREATE SESSION TO HOONZZANG;  -- CONNECT
REVOKE CREATE SESSION FROM HOONZZANG;

-- DROP USER
DROP USER HOONZZANG;

/* DBA ACCOUNT CREATION 
    SYS --> HOONZZANG :: 8888 :: DBA ROLE
   DEV ACCOUNT CREATION 
    DBA --> HOON :: 0000 :: CONNECT, RESOURCE ROLE
*/
-- DBA :: <- SYS
CREATE USER HOONZZANG
IDENTIFIED BY "8888";
GRANT DBA TO HOONZZANG;

-- DEV :: <-- DBA
CREATE USER HOON
IDENTIFIED BY "0000";
GRANT CONNECT, RESOURCE TO HOON;

-- USER CHECK
SELECT * FROM DBA_USERS;

-- DROP ANONYMOUS ACCOUNT
DROP USER ANONYMOUS;

-- 객체 권한 조회
SELECT * FROM USER_TAB_PRIVS;
SELECT * FROM USER_TAB_PRIVS_MADE;
SELECT * FROM USER_TAB_PRIVS_RECD;

-- ROLE에 부여된 시스템 || 객체 권한
SELECT * FROM ROLE_SYS_PRIVS WHERE ROLE = 'DBA';
SELECT * FROM ROLE_TAB_PRIVS WHERE ROLE = 'RESOURCE';
SELECT * FROM USER_ROLE_PRIVS;

/* USER CREATION
    SYN___
    CREATE USER [USER_NAME] IDENTIFIED BY "[PASSWORD]"
    *DEFAULT TABLESPACE [TBS_NAME]
    TEMPORATY TABLESPACE [TBS_NAME]
    *QUOTA [INTEGER M | UNLIMITED] ON [TBS_NAME];
*/

/* DBA :: USERS  :: UNLIMITED */
ALTER USER HOONZZANG
DEFAULT TABLESPACE USERS
QUOTA UNLIMITED ON USERS;

/* DEV :: USERS  :: UNLIMITED */
ALTER USER HOON
DEFAULT TABLESPACE USERS
QUOTA UNLIMITED ON USERS;

SELECT * FROM DBA_USERS;

/* 테이블 설계 시 알아야 할 내용 
   0. PROCESS 
      ENTITY 도출 --> ENTITY 배치 --> ENTITY RELATIONSHIP
      
   1. ENTITY
      - KEY ENTITY
      - MAIN ENTITY
      - ACTION ENTITY
      - PRODUCTION ENTITY
   2. NORMALIZATION
   3. ATTRIBUTE
   4. IDENTIFIER
   5. RELATIONSHIP
   6. DOMAIN
*/

/* 2020-10-20 :: TABLE
    PROCESS
      1. CREATE :: ATTRIBUTES 
      2. CREATE :: TABLESPACE 
      3. ALTER  :: CONSTRAINTS
      4. CREATE :: SYNONYM  --> 소유주만 사용가능
                :: PUBLIC SYNONYM --> 소유주 뿐만 아니라 권한을 부여받은 계정도 사용
                   --> DML구문에서만 사용 가능 
      5. GRANT  :: OBJECT PRIVILEGE
      
    SYNTAX____________
    CREATE TABLE [TAB_NAME](
      [COL_NAME]    [DATA-TYPE]     [PROPERTY],
          :              :               :    ,
      [COL_NAME]    [DATA-TYPE]     [PROPERTY],
      CONSTRAINT 
    )TABLESPACE [TBS_NAME];
*/
-- 1. DBA :: STORE TABLE(ST)
CREATE TABLE STORES(
 ST_CODE    NCHAR(4),
 ST_NAME    NVARCHAR2(100) NOT NULL,
 ST_ADDR    NVARCHAR2(100)
)TABLESPACE USERS;

/* CONSTRAINTS 
    : 특정 테이블의 특정 컬럼에 입력 제한 용도
    1. PRIMARY KEY
       - 하나의 테이블에 한 개의 PK 지정 가능
       - UNIQUE
       - NOT NULL
*/
-- ADD
ALTER TABLE STORES
ADD CONSTRAINT ST_CODE_PK  PRIMARY KEY(ST_CODE);
-- DROP
ALTER TABLE STORES
DROP CONSTRAINT ST_CODE_PK;

-- DATA INSERT
INSERT INTO STORES(ST_CODE, ST_NAME, ST_ADDR) 
VALUES('I001', '훈이네마켓', '인천시 미추홀구 학익동');
INSERT INTO STORES(ST_CODE, ST_NAME, ST_ADDR) 
VALUES('I001', '훈이네마켓', '인천시 미추홀구 학익동'); --> X
INSERT INTO STORES(ST_CODE, ST_NAME, ST_ADDR) 
VALUES( NULL, '훈이네마켓', '인천시 미추홀구 학익동');  --> X

   /* ALTER 의 활용 
    SUB COMMAND :   ADD --> 컬럼 추가
                    ADD CONSTRAINT --> 제약조건 추가
                    DROP COLUMN --> 컬럼 제거
                    DROP CONSTRAINT --> 제약조건 제거
                    MODIFY  --> 컬럼 수정
   */
   -- 컬럼 수정(DATA TYPE, PROPERTY)
   ALTER TABLE STORES MODIFY ST_ADDR NOT NULL;
   -- 컬럼 제거
   ALTER TABLE STORES DROP COLUMN ST_ADDR;
   -- 컬럼 추가
   ALTER TABLE STORES ADD ST_ADDR  NVARCHAR2(100);
   -- -- 컬럼 수정(DATA TYPE, PROPERTY)
   UPDATE STORES SET ST_ADDR = '인천광역시 미추홀구 학익동' WHERE ST_CODE = 'I001';
   ALTER TABLE STORES MODIFY ST_ADDR NOT NULL;
   
/* SYNONYM
    : 특정 테이블의 호출 이름을 별칭으로 가능
    : SYNONYM을 CREATE한 계정만이 사용 가능
    : DML구문(INSERT, UPDATE, DELETE, SELECT)사용 가능
    SYNTAX________
    CREATE SYNONYM [TAB_ALIAS] FOR [OBJECT]
*/
CREATE SYNONYM ST FOR COMEIN.STORES;
DROP SYNONYM ST;
SELECT * FROM ST;

/* OBJECT PRIVILEGE :: 개체 소유자
    SYNTAX___________
    GRANT [OBJ_PRIV_NAME], ... , [OBJ_PRIV_NAME] ON [OBJECT] TO [SCHEMA]
*/
GRANT SELECT ON COMEIN.STORES TO DOOLY, GILDONG, DOUNER, HEEDONG;
-- HOON조회
SELECT * FROM HOONZZANG.STORES;

--> DBA : PUBLIC SYNONYM 
CREATE PUBLIC SYNONYM ST FOR HOONZZANG.STORES;
   --> HOON 사용
   SELECT * FROM ST;
   
-- 2. DBA :: GOODS TABLE(GO)
CREATE TABLE GOODS(
GO_CODE NCHAR(4),
GO_NAME NVARCHAR2(50),
GO_PRICE NUMBER(6,0),
GO_COMMENTS NVARCHAR2(100)
) TABLESPACE USERS;

 -- PROPERTY
ALTER TABLE GOODS
MODIFY GO_CODE NOT NULL
MODIFY GO_NAME NOT NULL
MODIFY GO_PRICE DEFAULT 0;

 -- 2-3. CONSTRAINTS 
ALTER TABLE GOODS
ADD CONSTRAINT GO_CODE_PK PRIMARY KEY(GO_CODE);
 -- 2-4. SYNONYM
CREATE PUBLIC SYNONYM GO FOR DAN.GOODS; 
 -- 2-5. GRANT 
GRANT SELECT, INSERT ON DAN.GOODS TO DANY;

 -- 2-6. TEST DATA  <-- DEV
 INSERT INTO GO(GO_CODE, GO_NAME, GO_PRICE, GO_COMMENTS) 
 VALUES('1001', '새우깡', 1500, '일반');
 INSERT INTO GO(GO_CODE, GO_NAME, GO_PRICE, GO_COMMENTS) 
 VALUES('1002', '새우깡', 3000, '노래방');
 
 SELECT * FROM GO;


-- 3. DBA :: CUSTOMER TABLE(CM)
CREATE TABLE CUSTOMER(
CM_CODE NCHAR(5),
CM_NAME NVARCHAR2(5)
) TABLESPACE USERS;

 -- PROPERTY
 ALTER TABLE CUSTOMER
 MODIFY CM_CODE NOT NULL;
 
 -- 3-3. CONSTRAINTS 
 ALTER TABLE CUSTOMER
 ADD CONSTRAINT CM_CODE_PK PRIMARY KEY(CM_CODE);
 
 -- 3-4. SYNONYM
 CREATE PUBLIC SYNONYM CM FOR DAN.CUSTOMER;
 
 -- 3-5. GRANT
 GRANT SELECT, INSERT ON DAN.CUSTOMER TO DANY;
 
 GRANT DELETE ON DAN.CUSTOMER TO DANY;
 
 
 -- 3-6. TEST DATA  <-- DEV
 INSERT INTO CM(CM_CODE, CM_NAME) VALUES('C0001', '다사가');
 INSERT INTO CM(CM_CODE, CM_NAME) VALUES('C0002', '더없어');
 INSERT INTO CM(CM_CODE, CM_NAME) VALUES('C0003', '또왔어');
 INSERT INTO CM(CM_CODE, CM_NAME) VALUES('C0000', '비회원');
 
 
-- 폰번호 넣기
ALTER TABLE CUSTOMER
ADD CM_PHONE NCHAR(11);

UPDATE CUSTOMER SET CM_PHONE = '01011112222' WHERE CM_CODE = 'C0001';

 
 SELECT * FROM CM;
-- CHECK
SELECT * FROM DAN.STORES;
SELECT * FROM USER_TABLES;
SELECT * FROM USER_TAB_COLS WHERE TABLE_NAME = 'STORES';
SELECT * FROM USER_CONSTRAINTS;


DELETE FROM CM WHERE CM_CODE = 'C0002';
INSERT INTO CM (CM_CODE , CM_NAME) VALUES ('C0002','더있어');
COMMIT;

-- TABLE CREATE
CREATE TABLE EMPLOYEES(
EM_STCODE NCHAR(4),
EM_CODE NCHAR(4),
EM_PWD NVARCHAR2(10),
EM_NAME NVARCHAR2(5)
)TABLESPACE USERS;

-- PROPERTY
ALTER TABLE EMPLOYEES
MODIFY EM_STCODE NOT NULL
MODIFY EM_CODE NOT NULL
MODIFY EM_PWD NOT NULL
MODIFY EM_NAME NOT NULL;

-- CONSTRINT
ALTER TABLE EMPLOYEES
ADD CONSTRAINT EM_STCODE_CODE_PK PRIMARY KEY (EM_STCODE, EM_CODE);
ALTER TABLE EMPLOYEES
ADD CONSTRAINT EM_STCODE_FK FOREIGN KEY (EM_STCODE) REFERENCES DAN.STORES(ST_CODE);

 -- 테이블 권한 검색법
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'EMPLOYEES';

-- SYNONYM
CREATE PUBLIC SYNONYM "EM" FOR DAN.EMPLOYEES;

-- GRANT
GRANT ALL ON DAN.EMPLOYEES TO DANY;

-- INSERT
INSERT INTO "EM" (EM_STCODE, EM_CODE, EM_PWD, EM_NAME) VALUES ('I001','E001','0000','팔고싶어');

SELECT * FROM "EM";
-- TABLE CREATE
CREATE TABLE STOCK(
SC_GOCODE NCHAR(4),
SC_CODE DATE,
SC_STOCKS  NUMBER(3,0),
SC_EXPIRE DATE
) TABLESPACE USERS;

-- PROPERTY
ALTER TABLE STOCK
MODIFY SC_STOCKS NOT NULL
MODIFY SC_EXPIRE NOT NULL;

-- CONSTRAINT
ALTER TABLE STOCK
ADD CONSTRAINT SC_GOCODE_CODE_PK PRIMARY KEY (SC_GOCODE, SC_CODE);
ALTER TABLE STOCK
ADD CONSTRAINT SC_CODE_FK FOREIGN KEY(SC_GOCODE) REFERENCES DAN.GOODS(GO_CODE);

-- SYNONYM
CREATE PUBLIC SYNONYM SC FOR DAN.STOCK;

-- GRANT
GRANT ALL ON DAN.STOCK TO DANY;

-- INSERT

INSERT INTO SC(SC_GOCODE, SC_CODE, SC_STOCKS, SC_EXPIRE) VALUES ('1001',SYSDATE,5,'20201220');

-- COLUMN DELETE 
ALTER TABLE STOCK
DROP COLUMN SC_STOCKS;

-- ADD COLUMN
ALTER TABLE STOCK
ADD SC_STOCKS NUMBER(3,0) DEFAULT 0;

-- UPDATE
UPDATE SC SET SC_STOCKS = 10;

SELECT * FROM SC;

COMMIT;

-- REVOKE PREVILIGE
REVOKE UPDATE, SELECT, INSERT ON WELCOME.STORES FROM "DOOL";

-- DELETE WIHTOUT TABLESPACES
DROP USER DOOL;

-- DELETE WIHT TABLESPACES
DROP USER DOOL CASCADE;

-- USER CHECK :: DBA
SELECT * FROM DBA_USERS;


-- TABLE CHECK :: DBA
SELECT * FROM USER_TABLES;
SELECT * FROM USER_TAB_COLS WHERE TABLE_NAME = 'GOODS';
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'GOODS';


-- SEARCH FOR PREVILIGE
SELECT * FROM USER_TAB_PRIVS WHERE GRANTEE = 'DOOL';

-- SEARCH FOR PREVILIGE MADE BY OWN
SELECT * FROM USER_TAB_PRIVS_MADE WHERE GRANTEE = 'DOOL';

-- CHECK MY PREVILIGE
SELECT * FROM USER_TAB_PRIVS_RECD;

-- CM GO ST
CREATE PUBLIC SYNONYM CM FOR WELCOME.CUSTOMER; 
GRANT SELECT ON GO TO DOOL,GIL,DONG,DOU; 

ALTER TABLE WELCOME.STOCK 
MODIFY SC_CODE DEFAULT SYSDATE;

-- GOODS STOCK
DELETE FROM SC WHERE GO_CODE = '1003';
SELECT * FROM GO;

--------------------------------------------------------------------------------------------------------------- REGISTER GOODS
INSERT INTO GO(GO_CODE, GO_NAME, GO_PRICE, GO_COMMENTS) VALUES ('1001', '신라면', '1000', '너무 매움');
INSERT INTO GO(GO_CODE, GO_NAME, GO_PRICE, GO_COMMENTS) VALUES ('1002', '진라면', '1000', '매움');
INSERT INTO GO(GO_CODE, GO_NAME, GO_PRICE, GO_COMMENTS) VALUES ('3001', '삼각김밥', '1500', '참치가맛있음');
INSERT INTO GO(GO_CODE, GO_NAME, GO_PRICE, GO_COMMENTS) VALUES ('2001', '햄버거', '7000', '맛있음');
INSERT INTO GO(GO_CODE, GO_NAME, GO_PRICE, GO_COMMENTS) VALUES ('2002', '파스타', '8000', '고급스러움');
INSERT INTO GO(GO_CODE, GO_NAME, GO_PRICE, GO_COMMENTS) VALUES ('4001', '뼈해장국', '8000', '든든함');
INSERT INTO GO(GO_CODE, GO_NAME, GO_PRICE, GO_COMMENTS) VALUES ('9001', '민트초코', '10000', '구와와오아가각');
INSERT INTO GO(GO_CODE, GO_NAME, GO_PRICE, GO_COMMENTS) VALUES ('9002', '파인애플피자', '15000', '난맛있는데?');

--------------------------------------------------------------------------------------------------------------- REGISTER STOCK
INSERT INTO SC(SC_GOCODE, SC_CODE, SC_STOCKS, SC_EXPIRE) VALUES ('1001', DEFAULT, 50, '20501231');
INSERT INTO SC(SC_GOCODE, SC_CODE, SC_STOCKS, SC_EXPIRE) VALUES ('1002', DEFAULT, 50, '20501231');
INSERT INTO SC(SC_GOCODE, SC_CODE, SC_STOCKS, SC_EXPIRE) VALUES ('3001', DEFAULT, 20, '20201030');
INSERT INTO SC(SC_GOCODE, SC_CODE, SC_STOCKS, SC_EXPIRE) VALUES ('2001', DEFAULT, 30, '20201231');
INSERT INTO SC(SC_GOCODE, SC_CODE, SC_STOCKS, SC_EXPIRE) VALUES ('2002', DEFAULT, 10, '20501231');
INSERT INTO SC(SC_GOCODE, SC_CODE, SC_STOCKS, SC_EXPIRE) VALUES ('4001', DEFAULT, 30, '20501231');
INSERT INTO SC(SC_GOCODE, SC_CODE, SC_STOCKS, SC_EXPIRE) VALUES ('9001', DEFAULT, 50, '20201231');
INSERT INTO SC(SC_GOCODE, SC_CODE, SC_STOCKS, SC_EXPIRE) VALUES ('9002', DEFAULT, 50, '20201231');
INSERT INTO SC(SC_GOCODE, SC_CODE, SC_STOCKS, SC_EXPIRE) VALUES ('9002', DEFAULT, 10, '20511231');
COMMIT;

SELECT * FROM OD;

SELECT * FROM USER_TAB_COLS WHERE TABLE_NAME='ORDERS';

ALTER TABLE EMPLOYEES 
ADD EM_LEVEL NCHAR(1) DEFAULT 'A';

DELETE FROM PO;



/* 특정일(특정범위)의 상품별 판매 현황 
    -- 일일 매출현황
    -- 월별 매출현황
    ---------------------------------------------------
      상품코드     상품명       주문건수       매출액
       OT GO        GO           OT        OT * GO
    ---------------------------------------------------*/
CREATE OR REPLACE VIEW V1 AS 
SELECT TO_CHAR(OT.OT_ODCODE,'YYYYMMDD') AS TODATE,
OT.OT_GOCODE AS GOCODE, 
GO.GO_NAME AS GONAME,
COUNT(OT_GOCODE) AS CNT,
SUM(OT_QTY) AS TOTAL,
SUM(OT_QTY*GO_PRICE) AS AMOUNT
FROM GO INNER JOIN OT ON GO.GO_CODE = OT.OT_GOCODE
GROUP BY TO_CHAR(OT_ODCODE,'YYYYMMDD'), OT_GOCODE, GO_NAME;


SELECT TO_CHAR(OT_ODCODE,'YYYYMMDD'), OT_GOCODE
FROM OT
GROUP BY TO_CHAR(OT_ODCODE,'YYYYMMDD'), OT_GOCODE;


-- 일일매출
SELECT 
GOCODE,
GONAME,
CNT,
AMOUNT
FROM V1
WHERE TODATE = '20201016';

-- 월별 매출
SELECT 
GOCODE,
GONAME,
SUM(CNT),
SUM(AMOUNT)
FROM V1
WHERE SUBSTR(TODATE,1,6) = '202010'
GROUP BY GOCODE,GONAME;


  
/* 특정 상품의 월별 매출 추이 
    --------------------------------------
      매출월        주문건수       매출액
    --------------------------------------*/
    SELECT ANS, MUL
    FROM (SELECT 
          SUBSTR(TODATE,1,6) AS ANS, 
          SUM(TOTAL) AS MUL
          FROM V1  
          GROUP BY SUBSTR(TODATE,1,6)
    )QQ
    WHERE (ANS,MUL) IN(ODCODE);
    



/* 특정월의 베스트 상품(판매갯수) 현황 
    ------------------------------------------------------
      매출월    상품코드    상품명    주문건수       매출액
    ------------------------------------------------------*/
--    SELECT TO_CHAR(OT.OT_ODCODE,'YYYYMMDD') AS TODATE,
--OT.OT_GOCODE AS GOCODE, 
--GO.GO_NAME AS GONAME,
--COUNT(OT_GOCODE) AS CNT,
--SUM(OT_QTY) AS TOTAL,
--SUM(OT_QTY*GO_PRICE) AS AMOUNT
    


 CREATE OR REPLACE VIEW V2 AS  
SELECT TO_CHAR(OT.OT_ODCODE,'YYYYMM') AS TODATE,
OT.OT_GOCODE AS GOCODE, 
GO.GO_NAME AS GONAME,
COUNT(OT_GOCODE) AS CNT,
SUM(OT_QTY) AS TOTAL,
SUM(OT_QTY*GO_PRICE) AS AMOUNT
FROM GO INNER JOIN OT ON GO.GO_CODE = OT.OT_GOCODE
GROUP BY TO_CHAR(OT_ODCODE,'YYYYMM'), OT_GOCODE, GO_NAME;
    



SELECT 
*
FROM V2
WHERE (TODATE, TOTAL) IN (
 SELECT
    KK,
    MAX(OO)
    FROM(
    SELECT 
    SUBSTR(TODATE,1,6) AS KK,
    SUM(TOTAL) AS OO
    FROM V1
    GROUP BY SUBSTR(TODATE,1,6),GOCODE,GONAME)QQ
    GROUP BY KK);



















